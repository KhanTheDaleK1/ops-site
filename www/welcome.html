<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GLOBAL UPLINKS</title>
    <style>
        body { 
            margin: 0; padding: 0; 
            background-color: #050505; 
            color: #00ff00; 
            font-family: 'Courier New', monospace; 
            overflow: hidden; 
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        /* LAYERS */
        #matrix-canvas { position: fixed; top: 0; left: 0; z-index: 0; opacity: 0.3; }
        #globe-canvas { position: absolute; z-index: 1; opacity: 0.8; }
        
        .ui-layer { 
            position: relative; 
            z-index: 10; 
            text-align: center; 
            width: 100%;
            max-width: 1000px;
        }

        h1 { 
            font-size: 1.5rem; 
            letter-spacing: 5px; 
            text-shadow: 0 0 10px #00ff00; 
            margin-bottom: 5px;
            background: rgba(0,0,0,0.6);
            display: inline-block;
            padding: 5px 20px;
            border: 1px solid #004400;
        }
        p { opacity: 0.7; font-size: 0.8rem; margin-bottom: 40px; background: rgba(0,0,0,0.6); display: inline-block; padding: 2px 10px;}

        /* CARDS GRID */
        .grid { 
            display: flex; 
            justify-content: center; 
            gap: 30px; 
            flex-wrap: wrap;
        }
        
        .card { 
            border: 1px solid #00ff00; 
            background: rgba(0, 10, 0, 0.85);
            padding: 20px; 
            width: 200px;
            text-decoration: none; 
            color: #00ff00; 
            transition: all 0.3s;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.2);
            backdrop-filter: blur(2px);
        }
        .card:hover { 
            background: #002200; 
            box-shadow: 0 0 20px #00ff00; 
            transform: translateY(-5px);
        }
        .card h3 { border-bottom: 1px dashed #004400; padding-bottom: 10px; margin-top: 0; font-size: 1rem; }
        .card p { background: transparent; padding: 0; margin: 0; font-size: 0.7rem; opacity: 0.8; }

    </style>
</head>
<body>

    <canvas id="matrix-canvas"></canvas>

    <canvas id="globe-canvas"></canvas>

    <div class="ui-layer">
        <h1>// GLOBAL UPLINKS //</h1><br>
        <p>SECURE DATA AGGREGATION NODES</p>
        
        <div class="grid">
            <a href="https://flightaware.com/adsb/stats/user/KhanTheDalek" target="_blank" class="card">
                <h3>FLIGHTAWARE</h3>
                <p>STATION STATISTICS</p>
            </a>
            
            <a href="https://www.flightradar24.com/account/feed-stats" target="_blank" class="card">
                <h3>FLIGHTRADAR24</h3>
                <p>FEEDER T-KAEX8</p>
            </a>
            
            <a href="https://www.adsbexchange.com/myip/" target="_blank" class="card">
                <h3>ADSB EXCHANGE</h3>
                <p>MLAT SYNC STATUS</p>
            </a>

            <a href="https://beechem.site" target="_blank" class="card" style="border-style: dashed;">
                <h3>BEECHEM.SITE</h3>
                <p>PUBLIC PROFILE</p>
            </a>
        </div>
    </div>

    <script>
        /**
         * GLOBAL UPLINKS DASHBOARD SCRIPT
         * @version 1.0.0
         */

        // --- 1. MATRIX EFFECT ---
        // TODO: This logic is duplicated in 'matrix.js'. Refactor into a shared module.
        const mc = document.getElementById("matrix-canvas");
        const mCtx = mc.getContext("2d");
        
        function resizeMatrix() { mc.height = window.innerHeight; mc.width = window.innerWidth; }
        resizeMatrix();
        
        const chars = "010101XYZ0101";
        const charArr = chars.split("");
        const fontSize = 14;
        let columns = mc.width / fontSize;
        let drops = [];
        for(let x=0; x<columns; x++) drops[x] = 1;

        /**
         * Draws a single frame of the 'Matrix' digital rain effect.
         * Renders green characters trailing down the screen.
         */
        function drawMatrix() {
            mCtx.fillStyle = "rgba(0, 0, 0, 0.05)";
            mCtx.fillRect(0, 0, mc.width, mc.height);
            mCtx.fillStyle = "#0F0";
            mCtx.font = fontSize + "px monospace";
            
            for(let i=0; i<drops.length; i++) {
                const text = charArr[Math.floor(Math.random()*charArr.length)];
                mCtx.fillText(text, i*fontSize, drops[i]*fontSize);
                if(drops[i]*fontSize > mc.height && Math.random() > 0.975) drops[i] = 0;
                drops[i]++;
            }
        }
        setInterval(drawMatrix, 50);

        // --- 2. WIREFRAME GLOBE ---
        const gc = document.getElementById("globe-canvas");
        const gCtx = gc.getContext("2d");
        
        let sphere = { points: [], rotation: 0 };
        const radius = 250; 
        const numPoints = 600;

        function resizeGlobe() { 
            gc.width = window.innerWidth; 
            gc.height = window.innerHeight; 
            initGlobe();
        }

        /**
         * Initializes the 3D sphere points using a Fibonacci Sphere algorithm.
         * This ensures an even distribution of points on the sphere surface.
         */
        function initGlobe() {
            sphere.points = [];
            for (let i = 0; i < numPoints; i++) {
                // Fibonacci Sphere Algorithm for even distribution
                const y = 1 - (i / (numPoints - 1)) * 2;
                const radiusAtY = Math.sqrt(1 - y * y);
                const theta = i * 2.39996; // Golden angle increment
                
                const x = Math.cos(theta) * radiusAtY;
                const z = Math.sin(theta) * radiusAtY;
                sphere.points.push({x: x * radius, y: y * radius, z: z * radius});
            }
        }

        /**
         * Renders the rotating wireframe globe.
         * Applies 3D rotation math and simple perspective projection.
         */
        function drawGlobe() {
            gCtx.clearRect(0, 0, gc.width, gc.height);
            const cx = gc.width / 2;
            const cy = gc.height / 2;

            sphere.rotation += 0.005;
            
            gCtx.fillStyle = "#00ff00";
            
            sphere.points.forEach(p => {
                // Rotate around Y axis
                const rx = p.x * Math.cos(sphere.rotation) - p.z * Math.sin(sphere.rotation);
                const rz = p.x * Math.sin(sphere.rotation) + p.z * Math.cos(sphere.rotation);
                
                // Simple perspective
                const scale = 400 / (400 - rz);
                const x2d = rx * scale + cx;
                const y2d = p.y * scale + cy;
                const size = 1.5 * scale;

                if(scale > 0) { // Only draw front points
                    gCtx.globalAlpha = Math.max(0.1, (scale - 0.5)); // Fade back points
                    gCtx.beginPath();
                    gCtx.arc(x2d, y2d, size, 0, Math.PI * 2);
                    gCtx.fill();
                }
            });
            requestAnimationFrame(drawGlobe);
        }

        window.addEventListener('resize', () => { resizeMatrix(); resizeGlobe(); });
        initGlobe();
        drawGlobe();

    </script>
</body>
</html>
