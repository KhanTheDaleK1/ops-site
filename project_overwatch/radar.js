/**
 * PROJECT OVERWATCH - TACTICAL RADAR CONTROLLER
 * 
 * This script powers the main tactical display.
 * Dependencies:
 * - Leaflet.js (Map engine)
 * - /tar1090/data/aircraft.json (Real-time aircraft feed)
 * - /intel/ (Endpoint serving static JSON/JPG files generated by intel_gatherer.py)
 * 
 * @version 1.2.0
 * @author Evan Beechem
 * @system Cyber-Ops / Overwatch
 */

const CENTER_LAT = 31.3274; 
const CENTER_LON = -92.5486;
const ZOOM_LEVEL = 10;      
const DATA_URL = '/tar1090/data/aircraft.json'; 

const map = L.map('map', { zoomControl: false, attributionControl: false }).setView([CENTER_LAT, CENTER_LON], ZOOM_LEVEL);
L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 19 }).addTo(map);
L.tileLayer('https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/nexrad-n0q-900913/{z}/{x}/{y}.png', { maxZoom: 19, opacity: 0.6, className: 'weather-layer' }).addTo(map);

function drawTacticalGrid() {
    const gridGroup = L.layerGroup().addTo(map);
    const latMin = CENTER_LAT - 1.5, latMax = CENTER_LAT + 1.5;
    const lonMin = CENTER_LON - 2.0, lonMax = CENTER_LON + 2.0;
    const step = 0.1; 
    const gridStyle = { color: '#004400', weight: 1, opacity: 0.5, interactive: false };
    for (let lat = latMin; lat <= latMax; lat += step) L.polyline([[lat, lonMin], [lat, lonMax]], gridStyle).addTo(gridGroup);
    for (let lon = lonMin; lon <= lonMax; lon += step) L.polyline([[latMin, lon], [latMax, lon]], gridStyle).addTo(gridGroup);
    [10, 25, 50].forEach(nm => { L.circle([CENTER_LAT, CENTER_LON], { radius: nm * 1852, color: '#004400', fill: false, dashArray: '5, 10', weight: 1, interactive: false }).addTo(map); });
}
drawTacticalGrid();

const baseIcon = L.divIcon({ className: 'plane-icon', html: '', iconSize: [24, 24], iconAnchor: [12, 12] });
let aircraftMarkers = {};
let selectedHex = null;
let intelCache = {}; // Memory Cache

/**
 * Main polling function.
 * Fetches aircraft data, sorts it by distance, applies IFF logic, and updates map markers.
 * Runs every 1 second.
 */
async function updateRadar() {
    try {
        const response = await fetch(DATA_URL);
        const data = await response.json();
        const aircraftList = data.aircraft;
        
        document.getElementById('aircraft-count').innerText = `TARGETS: ${aircraftList.length}`;
        const activeHexes = new Set();
        const tableBody = document.querySelector('#target-table tbody');
        if(tableBody) tableBody.innerHTML = ''; 

        // Sorting
        aircraftList.forEach(p => { 
            p._distance = (p.lat && p.lon) ? map.distance([CENTER_LAT, CENTER_LON], [p.lat, p.lon]) : 99999999; 
        });
        aircraftList.sort((a, b) => a._distance - b._distance);

        // Sidebar Update
        if(selectedHex) { 
            const p = aircraftList.find(p => p.hex === selectedHex); 
            if(p) updateDetailPanel(p); 
        }

        // --- SCANNING LOOP ---
        // * INFO: We attempt to pre-load data for every plane on screen
        aircraftList.forEach(plane => {
            if (!plane.lat || !plane.lon) return; 
            activeHexes.add(plane.hex);
            
            // PRE-FETCH TRIGGER
            if (!intelCache[plane.hex]) {
                // // TODO: Optimized pre-loader. 
                // // FIXME: This currently triggers a fetch for every single plane every second until cached.
                // // It should likely have a 'pending' state to prevent duplicate requests.
                // Silently attempt to load local JSON
                preloadIntel(plane.hex);
            }

            // --- IFF LOGIC (Identification Friend or Foe) ---
            // TODO: Extract IFF logic into a separate 'getIFFStatus(plane)' function.
            let iffClass = 'iff-unk'; // Default: Unknown (Red)

            // MILITARY: 'dbFlags' bit 1 indicates military database flag
            if (plane.dbFlags && (plane.dbFlags & 1)) iffClass = 'iff-mil';
            
            // LEO/EMS: Category A7 (Parachutists/Tactical), B2 (Balloon), or 'MED' callsign
            else if (plane.category === "A7" || plane.category === "B2" || (plane.flight && plane.flight.trim().startsWith("MED"))) iffClass = 'iff-leo';
            
            // COMMERCIAL: Standard airline format (3 letters + numbers, e.g., AAL123)
            else if (plane.flight && /^[A-Z]{3}\d+/.test(plane.flight.trim())) iffClass = 'iff-com';
            
            let symbol = '✈'; let size = '26px'; let yOffset = '-2px';
            if (plane.category) {
                if (['A7','B7'].includes(plane.category)) { symbol = '✖'; size = '24px'; yOffset = '0px'; }
                else if (['A1','A2','B1','B2'].includes(plane.category)) { size = '18px'; }
                else if (['A5','A6','B5','B6','C5'].includes(plane.category)) { size = '36px'; }
            }
            const rot = plane.track || 0;
            const iconHtml = `<div class="${iffClass}" style="font-size: ${size}; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; transform: rotate(${rot - 45}deg); margin-top: ${yOffset};">${symbol}</div>`;

            if (aircraftMarkers[plane.hex]) {
                const marker = aircraftMarkers[plane.hex];
                marker.setLatLng([plane.lat, plane.lon]);
                const iconDiv = marker.getElement();
                if(iconDiv) iconDiv.innerHTML = iconHtml;
            } else {
                const newMarker = L.marker([plane.lat, plane.lon], {icon: baseIcon}).addTo(map);
                const iconDiv = newMarker.getElement();
                if(iconDiv) iconDiv.innerHTML = iconHtml;
                newMarker.on('click', () => { selectAircraft(plane.hex); });
                aircraftMarkers[plane.hex] = newMarker;
            }

            if(tableBody) {
                const row = document.createElement('tr');
                let rowColor = '#88ff88';
                if(iffClass === 'iff-mil') rowColor = '#ffffff';
                if(iffClass === 'iff-leo') rowColor = '#0088ff';
                if(iffClass === 'iff-unk') rowColor = '#ff3333';
                row.style.color = rowColor;
                row.innerHTML = `<td><strong>${plane.flight ? plane.flight.trim() : plane.hex}</strong></td><td>${plane.alt_baro || '-'}</td><td>${plane.gs || '-'}</td><td>${(plane._distance/1852).toFixed(1)}</td>`;
                row.addEventListener('click', () => { selectAircraft(plane.hex); });
                tableBody.appendChild(row);
            }
        });
        
        for (let hex in aircraftMarkers) { if (!activeHexes.has(hex)) { map.removeLayer(aircraftMarkers[hex]); delete aircraftMarkers[hex]; } }
    } catch (e) { console.log("Radar Error", e); }
}

// --- INTELLIGENCE ENGINE ---

// HYBRID PARSER: Fetches local JSON data generated by intel_gatherer.py
/**
 * Asynchronously checks for local intelligence files (JSON/JPG) for a given target.
 * Populates the `intelCache` to allow instant UI updates when a user selects a target.
 * @param {string} hex - The ICAO hex code.
 */
async function preloadIntel(hex) {
    try {
        const res = await fetch(`/intel/${hex.toLowerCase()}.json`);
        if(res.ok) {
            const data = await res.json();
            // Default Dossier
            let dossier = { src: null, reg: '---', type: '---', op: '---' };
            
            // 1. Load Data (Matches format from intel_gatherer.py)
            if(data.reg) dossier.reg = data.reg;
            if(data.type) dossier.type = data.type;
            if(data.ownOp) dossier.op = data.ownOp;
            
            // 2. Check for Photo (Local File)
            // We blindly assume .jpg might exist if json exists.
            // The browser will 404 quietly if it doesn't.
            dossier.src = `/intel/${hex.toLowerCase()}.jpg`;
            
            intelCache[hex] = dossier;
        } else {
             // Mark as checked to prevent 404 spam
            intelCache[hex] = { checked: true };
        }
    } catch(e) {}
}

function selectAircraft(hex) { 
    if (selectedHex === hex) return;
    selectedHex = hex; 
    
    const panel = document.getElementById('detail-panel');
    if(panel) panel.classList.remove('hidden'); 
    
    // Clear Visuals
    const img = document.getElementById('sel-photo'); 
    const ph = document.getElementById('sel-photo-placeholder');
    if(img) { img.style.display = 'none'; img.src = ""; }
    if(ph) ph.style.display = 'block';
    
    // Load Data
    if (intelCache[hex] && intelCache[hex].src) {
        // INSTANT LOAD FROM CACHE
        applyIntel(intelCache[hex]);
    } else {
        // FALLBACK: Try Fetching directly (if python script hasn't caught up)
        fetchMetadata(hex);
    }
}

function deselectAircraft() { 
    selectedHex = null; 
    document.getElementById('detail-panel').classList.add('hidden'); 
}

function applyIntel(data) {
    const img = document.getElementById('sel-photo');
    const ph = document.getElementById('sel-photo-placeholder');
    if(data.src && img) {
        img.src = data.src;
        img.onload = () => { img.style.display = 'block'; if(ph) ph.style.display = 'none'; };
    }
    if(data.reg) setText('sel-reg', data.reg);
    // setText('sel-type', data.type); // Optional if available
}

async function fetchMetadata(hex) {
    // Legacy fetcher for uncached targets
    try {
        setText('sel-op', 'SCANNING...');
        const res = await fetch(`/intel/${hex.toLowerCase()}.json`); // Try local first
        if(res.ok) {
            const data = await res.json();
            // ... parsing ... (Simplified for this block)
            // If local fails, we could try API direct, but let's rely on the Python bot.
        }
    } catch (e) { setText('sel-op', 'NO DATA'); }
}

function updateDetailPanel(p) {
    setText('sel-callsign', p.flight ? p.flight.trim() : 'NO CALLSIGN');
    setText('sel-hex', p.hex.toUpperCase());
    setText('sel-type', p.t || 'UNKNOWN');
    if(!document.getElementById('sel-reg').innerText.includes(p.r)) setText('sel-reg', p.r || '---');
    setText('sel-squawk', p.squawk || '---');
    setText('sel-alt', (p.alt_baro || 0) + ' ft');
    setText('sel-spd', (p.gs || 0) + ' kts');
    setText('sel-vrate', (p.baro_rate || 0) + ' fpm');
    setText('sel-trk', (p.track || 0) + '°');
    setText('sel-latlon', p.lat.toFixed(4) + ' / ' + p.lon.toFixed(4));
    setText('sel-rssi', (p.rssi || 0) + ' dBFS');
    
    // Status Indicator
    const cached = intelCache[p.hex] && intelCache[p.hex].src;
    setText('sel-op', cached ? 'INTEL: LOCKED' : 'INTEL: SCANNING...');
}

function setText(id, txt) { const el = document.getElementById(id); if(el) el.innerText = txt; }
function updateClock() { const el = document.getElementById('clock'); if(el) el.innerText = new Date().toLocaleTimeString('en-US', { hour12: false }); }
setInterval(updateRadar, 1000); setInterval(updateClock, 1000); updateRadar();
